//
// Topic.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct Topic: Codable {
    public var id: String?
    public var subject: String?
    public var message: GetFavoritesContextByID200ResponseCount?
    public var author: String?
    public var authorname: String?
    public var authorPathAlias: String?
    public var authorIsDeleted: Bool?
    public var isPro: Bool?
    public var role: String?
    public var iconserver: String?
    public var iconfarm: String?
    public var countReplies: Int?
    public var canEdit: Bool?
    public var canDelete: Bool?
    public var canReply: Bool?
    public var isSticky: Bool?
    public var isLocked: Bool?
    public var datecreate: String?
    public var datelastpost: String?
    public var lastReply: String?
    public var lastedit: String?

    public init(id: String? = nil, subject: String? = nil, message: GetFavoritesContextByID200ResponseCount? = nil, author: String? = nil, authorname: String? = nil, authorPathAlias: String? = nil, authorIsDeleted: Bool? = nil, isPro: Bool? = nil, role: String? = nil, iconserver: String? = nil, iconfarm: String? = nil, countReplies: Int? = nil, canEdit: Bool? = nil, canDelete: Bool? = nil, canReply: Bool? = nil, isSticky: Bool? = nil, isLocked: Bool? = nil, datecreate: String? = nil, datelastpost: String? = nil, lastReply: String? = nil, lastedit: String? = nil) {
        self.id = id
        self.subject = subject
        self.message = message
        self.author = author
        self.authorname = authorname
        self.authorPathAlias = authorPathAlias
        self.authorIsDeleted = authorIsDeleted
        self.isPro = isPro
        self.role = role
        self.iconserver = iconserver
        self.iconfarm = iconfarm
        self.countReplies = countReplies
        self.canEdit = canEdit
        self.canDelete = canDelete
        self.canReply = canReply
        self.isSticky = isSticky
        self.isLocked = isLocked
        self.datecreate = datecreate
        self.datelastpost = datelastpost
        self.lastReply = lastReply
        self.lastedit = lastedit
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case subject
        case message
        case author
        case authorname
        case authorPathAlias = "author_path_alias"
        case authorIsDeleted = "author_is_deleted"
        case isPro = "is_pro"
        case role
        case iconserver
        case iconfarm
        case countReplies = "count_replies"
        case canEdit = "can_edit"
        case canDelete = "can_delete"
        case canReply = "can_reply"
        case isSticky = "is_sticky"
        case isLocked = "is_locked"
        case datecreate
        case datelastpost
        case lastReply = "last_reply"
        case lastedit
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decodeIfPresent(String.self, forKey: .id)
        subject = try container.decodeIfPresent(String.self, forKey: .subject)
        message = try container.decodeIfPresent(GetFavoritesContextByID200ResponseCount.self, forKey: .message)
        author = try container.decodeIfPresent(String.self, forKey: .author)
        authorname = try container.decodeIfPresent(String.self, forKey: .authorname)
        authorPathAlias = try container.decodeIfPresent(String.self, forKey: .authorPathAlias)
        authorIsDeleted = try container.decodeIfPresent(Bool.self, forKey: .authorIsDeleted)
        isPro = try container.decodeIfPresent(Bool.self, forKey: .isPro)
        role = try container.decodeIfPresent(String.self, forKey: .role)
        iconserver = try container.decodeIfPresent(String.self, forKey: .iconserver)
        iconfarm = try container.decodeIfPresent(String.self, forKey: .iconfarm)
        countReplies = try container.decodeIfPresent(Int.self, forKey: .countReplies)
        canEdit = try container.decodeIfPresent(Bool.self, forKey: .canEdit)
        canDelete = try container.decodeIfPresent(Bool.self, forKey: .canDelete)
        canReply = try container.decodeIfPresent(Bool.self, forKey: .canReply)
        isSticky = try container.decodeIfPresent(Bool.self, forKey: .isSticky)
        isLocked = try container.decodeIfPresent(Bool.self, forKey: .isLocked)
        datecreate = try container.decodeIfPresent(String.self, forKey: .datecreate)
        datelastpost = try container.decodeIfPresent(String.self, forKey: .datelastpost)
        lastReply = try container.decodeIfPresent(String.self, forKey: .lastReply)
        lastedit = try container.decodeIfPresent(String.self, forKey: .lastedit)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(subject, forKey: .subject)
        try container.encodeIfPresent(message, forKey: .message)
        try container.encodeIfPresent(author, forKey: .author)
        try container.encodeIfPresent(authorname, forKey: .authorname)
        try container.encodeIfPresent(authorPathAlias, forKey: .authorPathAlias)
        try container.encodeIfPresent(authorIsDeleted, forKey: .authorIsDeleted)
        try container.encodeIfPresent(isPro, forKey: .isPro)
        try container.encodeIfPresent(role, forKey: .role)
        try container.encodeIfPresent(iconserver, forKey: .iconserver)
        try container.encodeIfPresent(iconfarm, forKey: .iconfarm)
        try container.encodeIfPresent(countReplies, forKey: .countReplies)
        try container.encodeIfPresent(canEdit, forKey: .canEdit)
        try container.encodeIfPresent(canDelete, forKey: .canDelete)
        try container.encodeIfPresent(canReply, forKey: .canReply)
        try container.encodeIfPresent(isSticky, forKey: .isSticky)
        try container.encodeIfPresent(isLocked, forKey: .isLocked)
        try container.encodeIfPresent(datecreate, forKey: .datecreate)
        try container.encodeIfPresent(datelastpost, forKey: .datelastpost)
        try container.encodeIfPresent(lastReply, forKey: .lastReply)
        try container.encodeIfPresent(lastedit, forKey: .lastedit)
    }
}
