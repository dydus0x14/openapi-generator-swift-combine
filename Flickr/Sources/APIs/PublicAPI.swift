//
// PublicAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class PublicAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://api.flickr.com/services")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// - GET /rest?method=flickr.test.echo
    /// - Echos the input parameters back in the response
    /// - parameter apiKey: (query)  
    /// - parameter echo: (query)  (optional)
    /// - returns: AnyPublisher<Echo200Response, Error> 
    open func echo(apiKey: String, echo: String? = nil) -> AnyPublisher<Echo200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.test.echo"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                if let echo = echo { queryItems.append(URLQueryItem(name: "echo", value: echo)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Echo200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(Echo200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /oauth/access_token
    /// - Returns an access token
    /// - parameter oauthConsumerKey: (query)  
    /// - parameter oauthNonce: (query)  
    /// - parameter oauthTimestamp: (query)  
    /// - parameter oauthSignatureMethod: (query)  
    /// - parameter oauthVersion: (query)  
    /// - parameter oauthSignature: (query)  
    /// - parameter oauthVerifier: (query)  
    /// - parameter oauthToken: (query)  
    /// - returns: AnyPublisher<String, Error> 
    open func getAccessToken(oauthConsumerKey: String, oauthNonce: String, oauthTimestamp: String, oauthSignatureMethod: String, oauthVersion: String, oauthSignature: String, oauthVerifier: String, oauthToken: String) -> AnyPublisher<String, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/oauth/access_token"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "oauth_consumer_key", value: oauthConsumerKey))
                queryItems.append(URLQueryItem(name: "oauth_nonce", value: oauthNonce))
                queryItems.append(URLQueryItem(name: "oauth_timestamp", value: oauthTimestamp))
                queryItems.append(URLQueryItem(name: "oauth_signature_method", value: oauthSignatureMethod))
                queryItems.append(URLQueryItem(name: "oauth_version", value: oauthVersion))
                queryItems.append(URLQueryItem(name: "oauth_signature", value: oauthSignature))
                queryItems.append(URLQueryItem(name: "oauth_verifier", value: oauthVerifier))
                queryItems.append(URLQueryItem(name: "oauth_token", value: oauthToken))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<String, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(String.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.photosets.getPhotos
    /// - Returns a list of photos in an album.
    /// - parameter apiKey: (query)  
    /// - parameter photosetId: (query)  
    /// - returns: AnyPublisher<GetAlbumByID200Response, Error> 
    open func getAlbumByID(apiKey: String, photosetId: String) -> AnyPublisher<GetAlbumByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.photosets.getPhotos"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "photoset_id", value: photosetId))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetAlbumByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetAlbumByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.photosets.getContext
    /// - Returns next and previous photos for a photo in a set
    /// - parameter apiKey: (query)  
    /// - parameter photoId: (query)  
    /// - parameter photosetId: (query)  (optional)
    /// - returns: AnyPublisher<GetFavoritesContextByID200Response, Error> 
    open func getAlbumContextByID(apiKey: String, photoId: String, photosetId: String? = nil) -> AnyPublisher<GetFavoritesContextByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.photosets.getContext"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "photo_id", value: photoId))
                if let photosetId = photosetId { queryItems.append(URLQueryItem(name: "photoset_id", value: photosetId)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetFavoritesContextByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetFavoritesContextByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.photosets.getList
    /// - Returns the albums belonging to the specified user
    /// - parameter apiKey: (query)  
    /// - parameter userId: (query)  
    /// - parameter page: (query)  (optional)
    /// - parameter perPage: (query)  (optional)
    /// - returns: AnyPublisher<GetAlbumsByPersonID200Response, Error> 
    open func getAlbumsByPersonID(apiKey: String, userId: String, page: Double? = nil, perPage: Double? = nil) -> AnyPublisher<GetAlbumsByPersonID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.photosets.getList"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "user_id", value: userId))
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let perPage = perPage { queryItems.append(URLQueryItem(name: "per_page", value: "\(perPage)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetAlbumsByPersonID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetAlbumsByPersonID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.favorites.getList
    /// - Returns a list of the user's favorite photos. Only photos which the calling user has permission to see are returned.
    /// - parameter apiKey: (query)  
    /// - parameter userId: (query)  
    /// - parameter minFaveDate: (query)  (optional)
    /// - parameter maxFaveDate: (query)  (optional)
    /// - parameter page: (query)  (optional)
    /// - parameter perPage: (query)  (optional)
    /// - returns: AnyPublisher<GetFavoritesByPersonID200Response, Error> 
    open func getFavoritesByPersonID(apiKey: String, userId: String, minFaveDate: Double? = nil, maxFaveDate: Double? = nil, page: Double? = nil, perPage: Double? = nil) -> AnyPublisher<GetFavoritesByPersonID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.favorites.getList"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "user_id", value: userId))
                if let minFaveDate = minFaveDate { queryItems.append(URLQueryItem(name: "min_fave_date", value: "\(minFaveDate)")) } 
                if let maxFaveDate = maxFaveDate { queryItems.append(URLQueryItem(name: "max_fave_date", value: "\(maxFaveDate)")) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let perPage = perPage { queryItems.append(URLQueryItem(name: "per_page", value: "\(perPage)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetFavoritesByPersonID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetFavoritesByPersonID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.favorites.getContext
    /// - Returns next and previous favorites for a photo in a user's favorites
    /// - parameter apiKey: (query)  
    /// - parameter photoId: (query)  
    /// - parameter userId: (query)  (optional)
    /// - returns: AnyPublisher<GetFavoritesContextByID200Response, Error> 
    open func getFavoritesContextByID(apiKey: String, photoId: String, userId: String? = nil) -> AnyPublisher<GetFavoritesContextByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.favorites.getContext"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "photo_id", value: photoId))
                if let userId = userId { queryItems.append(URLQueryItem(name: "user_id", value: userId)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetFavoritesContextByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetFavoritesContextByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.galleries.getPhotos
    /// - Returns a list of photos in a gallery.
    /// - parameter apiKey: (query)  
    /// - parameter galleryId: (query)  
    /// - returns: AnyPublisher<GetGroupPhotosByID200Response, Error> 
    open func getGalleryPhotosByID(apiKey: String, galleryId: String) -> AnyPublisher<GetGroupPhotosByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.galleries.getPhotos"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "gallery_id", value: galleryId))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetGroupPhotosByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetGroupPhotosByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.groups.getInfo
    /// - Get information about a group
    /// - parameter apiKey: (query)  
    /// - parameter groupId: (query)  (optional)
    /// - parameter groupPathAlias: (query)  (optional)
    /// - parameter lang: (query)  (optional)
    /// - returns: AnyPublisher<GetGroupByID200Response, Error> 
    open func getGroupByID(apiKey: String, groupId: String? = nil, groupPathAlias: String? = nil, lang: String? = nil) -> AnyPublisher<GetGroupByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.groups.getInfo"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                if let groupId = groupId { queryItems.append(URLQueryItem(name: "group_id", value: groupId)) } 
                if let groupPathAlias = groupPathAlias { queryItems.append(URLQueryItem(name: "group_path_alias", value: groupPathAlias)) } 
                if let lang = lang { queryItems.append(URLQueryItem(name: "lang", value: lang)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetGroupByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetGroupByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.groups.discuss.topics.getList
    /// - Get a list of discussion topics in a group.
    /// - parameter apiKey: (query)  
    /// - parameter groupId: (query)  (optional)
    /// - parameter page: (query)  (optional)
    /// - parameter perPage: (query)  (optional)
    /// - returns: AnyPublisher<GetGroupDiscussionsByID200Response, Error> 
    open func getGroupDiscussionsByID(apiKey: String, groupId: String? = nil, page: Double? = nil, perPage: Double? = nil) -> AnyPublisher<GetGroupDiscussionsByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.groups.discuss.topics.getList"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                if let groupId = groupId { queryItems.append(URLQueryItem(name: "group_id", value: groupId)) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let perPage = perPage { queryItems.append(URLQueryItem(name: "per_page", value: "\(perPage)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetGroupDiscussionsByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetGroupDiscussionsByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.groups.pools.getPhotos
    /// - Returns a list of pool photos for a given group
    /// - parameter apiKey: (query)  
    /// - parameter groupId: (query)  (optional)
    /// - returns: AnyPublisher<GetGroupPhotosByID200Response, Error> 
    open func getGroupPhotosByID(apiKey: String, groupId: String? = nil) -> AnyPublisher<GetGroupPhotosByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.groups.pools.getPhotos"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                if let groupId = groupId { queryItems.append(URLQueryItem(name: "group_id", value: groupId)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetGroupPhotosByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetGroupPhotosByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.groups.pools.getContext
    /// - Returns next and previous photos for a photo in a group pool
    /// - parameter apiKey: (query)  
    /// - parameter photoId: (query)  
    /// - parameter groupId: (query)  (optional)
    /// - returns: AnyPublisher<GetFavoritesContextByID200Response, Error> 
    open func getGroupPhotosByID_0(apiKey: String, photoId: String, groupId: String? = nil) -> AnyPublisher<GetFavoritesContextByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.groups.pools.getContext"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "photo_id", value: photoId))
                if let groupId = groupId { queryItems.append(URLQueryItem(name: "group_id", value: groupId)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetFavoritesContextByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetFavoritesContextByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.groups.discuss.topics.getInfo
    /// - Get information about a group discussion topic
    /// - parameter apiKey: (query)  
    /// - parameter topicId: (query)  
    /// - parameter groupId: (query)  (optional)
    /// - returns: AnyPublisher<GetGroupTopicByID200Response, Error> 
    open func getGroupTopicByID(apiKey: String, topicId: String, groupId: String? = nil) -> AnyPublisher<GetGroupTopicByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.groups.discuss.topics.getInfo"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                if let groupId = groupId { queryItems.append(URLQueryItem(name: "group_id", value: groupId)) } 
                queryItems.append(URLQueryItem(name: "topic_id", value: topicId))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetGroupTopicByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetGroupTopicByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.groups.discuss.replies.getInfo
    /// - Get information on a group topic reply
    /// - parameter apiKey: (query)  
    /// - parameter topicId: (query)  
    /// - parameter replyId: (query)  
    /// - parameter groupId: (query)  (optional)
    /// - returns: AnyPublisher<GetGroupTopicRepliesByID200Response, Error> 
    open func getGroupTopicRepliesByID(apiKey: String, topicId: String, replyId: String, groupId: String? = nil) -> AnyPublisher<GetGroupTopicRepliesByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.groups.discuss.replies.getInfo"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                if let groupId = groupId { queryItems.append(URLQueryItem(name: "group_id", value: groupId)) } 
                queryItems.append(URLQueryItem(name: "topic_id", value: topicId))
                queryItems.append(URLQueryItem(name: "reply_id", value: replyId))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetGroupTopicRepliesByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetGroupTopicRepliesByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.photos.licenses.getInfo
    /// - Fetches a list of available photo licenses for Flickr
    /// - parameter apiKey: (query)  
    /// - returns: AnyPublisher<GetLicenseByID200Response, Error> 
    open func getLicenseByID(apiKey: String) -> AnyPublisher<GetLicenseByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.photos.licenses.getInfo"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetLicenseByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetLicenseByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.people.getPhotos
    /// - Return photos from the given user's photostream
    /// - parameter apiKey: (query)  
    /// - parameter userId: (query)  
    /// - parameter safeSearch: (query)  (optional)
    /// - parameter minUploadDate: (query)  (optional)
    /// - parameter maxUploadDate: (query)  (optional)
    /// - parameter minTakenDate: (query)  (optional)
    /// - parameter maxTakenDate: (query)  (optional)
    /// - parameter contentType: (query)  (optional)
    /// - parameter privacyFilter: (query)  (optional)
    /// - parameter page: (query)  (optional)
    /// - parameter perPage: (query)  (optional)
    /// - returns: AnyPublisher<GetFavoritesByPersonID200Response, Error> 
    open func getMediaByPersonID(apiKey: String, userId: String, safeSearch: Double? = nil, minUploadDate: Double? = nil, maxUploadDate: Double? = nil, minTakenDate: Double? = nil, maxTakenDate: Double? = nil, contentType: Double? = nil, privacyFilter: Double? = nil, page: Double? = nil, perPage: Double? = nil) -> AnyPublisher<GetFavoritesByPersonID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.people.getPhotos"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "user_id", value: userId))
                if let safeSearch = safeSearch { queryItems.append(URLQueryItem(name: "safe_search", value: "\(safeSearch)")) } 
                if let minUploadDate = minUploadDate { queryItems.append(URLQueryItem(name: "min_upload_date", value: "\(minUploadDate)")) } 
                if let maxUploadDate = maxUploadDate { queryItems.append(URLQueryItem(name: "max_upload_date", value: "\(maxUploadDate)")) } 
                if let minTakenDate = minTakenDate { queryItems.append(URLQueryItem(name: "min_taken_date", value: "\(minTakenDate)")) } 
                if let maxTakenDate = maxTakenDate { queryItems.append(URLQueryItem(name: "max_taken_date", value: "\(maxTakenDate)")) } 
                if let contentType = contentType { queryItems.append(URLQueryItem(name: "content_type", value: "\(contentType)")) } 
                if let privacyFilter = privacyFilter { queryItems.append(URLQueryItem(name: "privacy_filter", value: "\(privacyFilter)")) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                if let perPage = perPage { queryItems.append(URLQueryItem(name: "per_page", value: "\(perPage)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetFavoritesByPersonID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetFavoritesByPersonID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.photos.search
    /// - Return a list of photos matching some criteria.
    /// - parameter apiKey: (query)  
    /// - parameter text: (query) A free text search. Photos who&#39;s title, description or tags contain the text will be returned. You can exclude results that match a term by prepending it with a - character. (optional)
    /// - parameter tags: (query) A comma-delimited list of tags. Photos with one or more of the tags listed will be returned. You can exclude results that match a term by prepending it with a - character. (optional)
    /// - parameter userId: (query) The NSID of the user who&#39;s photo to search. If this parameter isn&#39;t passed then everybody&#39;s public photos will be searched. A value of \&quot;me\&quot; will search against the calling user&#39;s photos for authenticated calls. (optional)
    /// - parameter minUploadDate: (query) Minimum upload date. Photos with an upload date greater than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime. (optional)
    /// - parameter maxUploadDate: (query) Maximum upload date. Photos with an upload date less than or equal to this value will be returned. The date can be in the form of a unix timestamp or mysql datetime. (optional)
    /// - parameter minTakenDate: (query) Minimum taken date. Photos with an taken date greater than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp. (optional)
    /// - parameter maxTakenDate: (query) Maximum taken date. Photos with an taken date less than or equal to this value will be returned. The date can be in the form of a mysql datetime or unix timestamp. (optional)
    /// - parameter license: (query) The license id for photos (for possible values see the flickr.photos.licenses.getInfo method). Multiple licenses may be comma-separated. (optional)
    /// - parameter sort: (query) The order in which to sort returned photos. Deafults to date-posted-desc (unless you are doing a radial geo query, in which case the default sorting is by ascending distance from the point specified). The possible values are:   date-posted-asc,   date-posted-desc,   date-taken-asc,   date-taken-desc,   interestingness-desc,   interestingness-asc, and   relevance.  (optional)
    /// - parameter privacyFilter: (query) Return photos only matching a certain privacy level. This only applies when making an authenticated call to view photos you own. Valid values are:,   1: public photos,   2: private photos visible to friends,   3: private photos visible to family,   4: private photos visible to friends &amp; family,   5: completely private photos  (optional)
    /// - parameter bbox: (query) A comma-delimited list of 4 values defining the Bounding Box of the area that will be searched. (optional)
    /// - parameter accuracy: (query) Recorded accuracy level of the location information. Current range is 1-16:   World level is 1   Country is ~3   Region is ~6   City is ~11   Street is ~16  (optional)
    /// - parameter safeSearch: (query) Safe search setting:   1: for safe,   2: for moderate,   3: for restricted  (optional)
    /// - parameter contentType: (query) Content Type setting:   1: photos only.   2: screenshots only.   3: &#39;other&#39; only.   4: photos and screenshots.   5: screenshots and &#39;other&#39;.   6: photos and &#39;other&#39;.   7: photos, screenshots, and &#39;other&#39; (all).  (optional)
    /// - parameter machineTags: (query) Aside from passing in a fully formed machine tag, there is a special syntax for searching on specific properties : Find photos using the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:\&quot; Find photos with a title in the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\&quot; Find photos titled \&quot;mr. camera\&quot; in the &#39;dc&#39; namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:title&#x3D;\\\&quot;mr. camera\\\&quot; Find photos whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos that have a title, in any namespace : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\&quot; Find photos that have a title, in any namespace, whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;*:title&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Find photos, in the &#39;dc&#39; namespace whose value is \&quot;mr. camera\&quot; : \&quot;machine_tags\&quot; &#x3D;&gt; \&quot;dc:*&#x3D;\\\&quot;mr. camera\\\&quot;\&quot; Multiple machine tags may be queried by passing a comma-separated list. The number of machine tags you can pass in a single query depends on the tag mode (AND or OR) that you are querying with. \&quot;AND\&quot; queries are limited to (16) machine tags. \&quot;OR\&quot; queries are limited to (8).  (optional)
    /// - parameter machineTagMode: (query) Either &#39;any&#39; for an OR combination of tags, or &#39;all&#39; for an AND combination. Defaults to &#39;any&#39; if not specified. (optional)
    /// - parameter groupId: (query) The id of a group who&#39;s pool to search. If specified, only matching photos posted to the group&#39;s pool will be returned. (optional)
    /// - parameter contacts: (query) Search your contacts. Either &#39;all&#39; or &#39;ff&#39; for just friends and family. (Experimental) (optional)
    /// - parameter woeId: (query) A 32-bit identifier that uniquely represents spatial entities. (not used if bbox argument is present). (optional)
    /// - parameter placeId: (query) A Flickr place id. (not used if bbox argument is present). Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters — If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
    /// - parameter media: (query) Filter results by media type. Possible values are all (default), photos or videos (optional)
    /// - parameter hasGeo: (query) Any photo that has been geotagged, or if the value is \&quot;0\&quot; any photo that has not been geotagged. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters — If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
    /// - parameter geoContext: (query) Geo context is a numeric value representing the photo&#39;s geotagginess beyond latitude and longitude. For example, you may wish to search for photos that were taken \&quot;indoors\&quot; or \&quot;outdoors\&quot;. The current list of context IDs is: 0, not defined. 1, indoors. 2, outdoors. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters — If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
    /// - parameter lat: (query) A valid latitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters — If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
    /// - parameter lon: (query) A valid longitude, in decimal format, for doing radial geo queries. Geo queries require some sort of limiting agent in order to prevent the database from crying. This is basically like the check against \&quot;parameterless searches\&quot; for queries without a geo component. A tag, for instance, is considered a limiting agent as are user defined min_date_taken and min_date_upload parameters — If no limiting factor is passed we return only photos added in the last 12 hours (though we may extend the limit in the future).  (optional)
    /// - parameter radius: (query) A valid radius used for geo queries, greater than zero and less than 20 miles (or 32 kilometers), for use with point-based geo queries. The default value is 5 (km). (optional)
    /// - parameter radiusUnits: (query) The unit of measure when doing radial geo queries. Valid options are \&quot;mi\&quot; (miles) and \&quot;km\&quot; (kilometers). The default is \&quot;km\&quot;. (optional)
    /// - parameter isCommons: (query) Limit the scope of the search to only photos that are part of the Flickr Commons project. Default is false. (optional)
    /// - parameter inGallery: (query) Limit the scope of the search to only photos that are in a gallery? Default is false, search all photos. (optional)
    /// - parameter isGetty: (query) Limit the scope of the search to only photos that are for sale on Getty. Default is false. (optional)
    /// - parameter perPage: (query) Number of photos to return per page. If this argument is omitted, it defaults to 100. The maximum allowed value is 500. (optional)
    /// - parameter page: (query) The page of results to return. If this argument is omitted, it defaults to 1. (optional)
    /// - returns: AnyPublisher<GetFavoritesByPersonID200Response, Error> 
    open func getMediaBySearch(apiKey: String, text: String? = nil, tags: String? = nil, userId: String? = nil, minUploadDate: String? = nil, maxUploadDate: String? = nil, minTakenDate: String? = nil, maxTakenDate: String? = nil, license: String? = nil, sort: String? = nil, privacyFilter: Double? = nil, bbox: String? = nil, accuracy: String? = nil, safeSearch: Double? = nil, contentType: Double? = nil, machineTags: String? = nil, machineTagMode: String? = nil, groupId: String? = nil, contacts: String? = nil, woeId: String? = nil, placeId: String? = nil, media: String? = nil, hasGeo: String? = nil, geoContext: String? = nil, lat: String? = nil, lon: String? = nil, radius: Double? = nil, radiusUnits: String? = nil, isCommons: Bool? = nil, inGallery: Bool? = nil, isGetty: Bool? = nil, perPage: Double? = nil, page: Double? = nil) -> AnyPublisher<GetFavoritesByPersonID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.photos.search"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                if let text = text { queryItems.append(URLQueryItem(name: "text", value: text)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let userId = userId { queryItems.append(URLQueryItem(name: "user_id", value: userId)) } 
                if let minUploadDate = minUploadDate { queryItems.append(URLQueryItem(name: "min_upload_date", value: minUploadDate)) } 
                if let maxUploadDate = maxUploadDate { queryItems.append(URLQueryItem(name: "max_upload_date", value: maxUploadDate)) } 
                if let minTakenDate = minTakenDate { queryItems.append(URLQueryItem(name: "min_taken_date", value: minTakenDate)) } 
                if let maxTakenDate = maxTakenDate { queryItems.append(URLQueryItem(name: "max_taken_date", value: maxTakenDate)) } 
                if let license = license { queryItems.append(URLQueryItem(name: "license", value: license)) } 
                if let sort = sort { queryItems.append(URLQueryItem(name: "sort", value: sort)) } 
                if let privacyFilter = privacyFilter { queryItems.append(URLQueryItem(name: "privacy_filter", value: "\(privacyFilter)")) } 
                if let bbox = bbox { queryItems.append(URLQueryItem(name: "bbox", value: bbox)) } 
                if let accuracy = accuracy { queryItems.append(URLQueryItem(name: "accuracy", value: accuracy)) } 
                if let safeSearch = safeSearch { queryItems.append(URLQueryItem(name: "safe_search", value: "\(safeSearch)")) } 
                if let contentType = contentType { queryItems.append(URLQueryItem(name: "content_type", value: "\(contentType)")) } 
                if let machineTags = machineTags { queryItems.append(URLQueryItem(name: "machine_tags", value: machineTags)) } 
                if let machineTagMode = machineTagMode { queryItems.append(URLQueryItem(name: "machine_tag_mode", value: machineTagMode)) } 
                if let groupId = groupId { queryItems.append(URLQueryItem(name: "group_id", value: groupId)) } 
                if let contacts = contacts { queryItems.append(URLQueryItem(name: "contacts", value: contacts)) } 
                if let woeId = woeId { queryItems.append(URLQueryItem(name: "woe_id", value: woeId)) } 
                if let placeId = placeId { queryItems.append(URLQueryItem(name: "place_id", value: placeId)) } 
                if let media = media { queryItems.append(URLQueryItem(name: "media", value: media)) } 
                if let hasGeo = hasGeo { queryItems.append(URLQueryItem(name: "has_geo", value: hasGeo)) } 
                if let geoContext = geoContext { queryItems.append(URLQueryItem(name: "geo_context", value: geoContext)) } 
                if let lat = lat { queryItems.append(URLQueryItem(name: "lat", value: lat)) } 
                if let lon = lon { queryItems.append(URLQueryItem(name: "lon", value: lon)) } 
                if let radius = radius { queryItems.append(URLQueryItem(name: "radius", value: "\(radius)")) } 
                if let radiusUnits = radiusUnits { queryItems.append(URLQueryItem(name: "radius_units", value: radiusUnits)) } 
                if let isCommons = isCommons { queryItems.append(URLQueryItem(name: "is_commons", value: isCommons ? "true" : "false")) } 
                if let inGallery = inGallery { queryItems.append(URLQueryItem(name: "in_gallery", value: inGallery ? "true" : "false")) } 
                if let isGetty = isGetty { queryItems.append(URLQueryItem(name: "is_getty", value: isGetty ? "true" : "false")) } 
                if let perPage = perPage { queryItems.append(URLQueryItem(name: "per_page", value: "\(perPage)")) } 
                if let page = page { queryItems.append(URLQueryItem(name: "page", value: "\(page)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetFavoritesByPersonID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetFavoritesByPersonID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.people.getInfo
    /// - Returns a person
    /// - parameter apiKey: (query)  
    /// - parameter userId: (query)  (optional)
    /// - returns: AnyPublisher<GetPersonByID200Response, Error> 
    open func getPersonByID(apiKey: String, userId: String? = nil) -> AnyPublisher<GetPersonByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.people.getInfo"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                if let userId = userId { queryItems.append(URLQueryItem(name: "user_id", value: userId)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetPersonByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetPersonByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.photos.getInfo
    /// - Returns a photo
    /// - parameter apiKey: (query)  
    /// - parameter photoId: (query)  
    /// - returns: AnyPublisher<GetPhotoByID200Response, Error> 
    open func getPhotoByID(apiKey: String, photoId: String) -> AnyPublisher<GetPhotoByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.photos.getInfo"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "photo_id", value: photoId))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetPhotoByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetPhotoByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.photos.getExif
    /// - Retrieves a list of EXIF/TIFF/GPS tags for a given photo. The calling user must have permission to view the photo.
    /// - parameter apiKey: (query)  
    /// - parameter photoId: (query)  
    /// - parameter secret: (query)  (optional)
    /// - returns: AnyPublisher<GetPhotoExifByID200Response, Error> 
    open func getPhotoExifByID(apiKey: String, photoId: String, secret: String? = nil) -> AnyPublisher<GetPhotoExifByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.photos.getExif"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "photo_id", value: photoId))
                if let secret = secret { queryItems.append(URLQueryItem(name: "secret", value: secret)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetPhotoExifByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetPhotoExifByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.photos.getSizes
    /// - Returns photo sizes
    /// - parameter apiKey: (query)  
    /// - parameter photoId: (query)  
    /// - returns: AnyPublisher<GetPhotoSizesByID200Response, Error> 
    open func getPhotoSizesByID(apiKey: String, photoId: String) -> AnyPublisher<GetPhotoSizesByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.photos.getSizes"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "photo_id", value: photoId))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetPhotoSizesByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetPhotoSizesByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.photolist.getContext
    /// - Returns next and previous photos in a photo list
    /// - parameter apiKey: (query)  
    /// - parameter photoId: (query)  
    /// - parameter photolistId: (query)  
    /// - returns: AnyPublisher<GetFavoritesContextByID200Response, Error> 
    open func getPhotolistContextByID(apiKey: String, photoId: String, photolistId: String) -> AnyPublisher<GetFavoritesContextByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.photolist.getContext"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "photo_id", value: photoId))
                queryItems.append(URLQueryItem(name: "photolist_id", value: photolistId))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetFavoritesContextByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetFavoritesContextByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /rest?method=flickr.photos.getContext
    /// - Returns next and previous photos for a photo in a photostream
    /// - parameter apiKey: (query)  
    /// - parameter photoId: (query)  
    /// - returns: AnyPublisher<GetFavoritesContextByID200Response, Error> 
    open func getPhotostreamContextByID(apiKey: String, photoId: String) -> AnyPublisher<GetFavoritesContextByID200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/rest?method&#x3D;flickr.photos.getContext"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "api_key", value: apiKey))
                queryItems.append(URLQueryItem(name: "photo_id", value: photoId))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetFavoritesContextByID200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetFavoritesContextByID200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// - GET /oauth/request_token
    /// - Returns an oauth token and oauth token secret
    /// - parameter oauthConsumerKey: (query)  
    /// - parameter oauthNonce: (query)  
    /// - parameter oauthTimestamp: (query)  
    /// - parameter oauthSignatureMethod: (query)  
    /// - parameter oauthVersion: (query)  
    /// - parameter oauthSignature: (query)  
    /// - parameter oauthCallback: (query)  
    /// - returns: AnyPublisher<String, Error> 
    open func getRequestToken(oauthConsumerKey: String, oauthNonce: String, oauthTimestamp: String, oauthSignatureMethod: String, oauthVersion: String, oauthSignature: String, oauthCallback: String) -> AnyPublisher<String, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/oauth/request_token"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "oauth_consumer_key", value: oauthConsumerKey))
                queryItems.append(URLQueryItem(name: "oauth_nonce", value: oauthNonce))
                queryItems.append(URLQueryItem(name: "oauth_timestamp", value: oauthTimestamp))
                queryItems.append(URLQueryItem(name: "oauth_signature_method", value: oauthSignatureMethod))
                queryItems.append(URLQueryItem(name: "oauth_version", value: oauthVersion))
                queryItems.append(URLQueryItem(name: "oauth_signature", value: oauthSignature))
                queryItems.append(URLQueryItem(name: "oauth_callback", value: oauthCallback))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<String, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(String.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter isPublic
    ///
    public enum UploadPhotoIsPublic: String, Codable, CaseIterable {
        case _0 = "0"
        case _1 = "1"
    }
    ///
    /// Enum for parameter isFriend
    ///
    public enum UploadPhotoIsFriend: String, Codable, CaseIterable {
        case _0 = "0"
        case _1 = "1"
    }
    ///
    /// Enum for parameter isFamily
    ///
    public enum UploadPhotoIsFamily: String, Codable, CaseIterable {
        case _0 = "0"
        case _1 = "1"
    }
    ///
    /// Enum for parameter safetyLevel
    ///
    public enum UploadPhotoSafetyLevel: String, Codable, CaseIterable {
        case _1 = "1"
        case _2 = "2"
        case _3 = "3"
    }
    ///
    /// Enum for parameter contentType
    ///
    public enum UploadPhotoContentType: String, Codable, CaseIterable {
        case _1 = "1"
        case _2 = "2"
        case _3 = "3"
    }
    ///
    /// Enum for parameter hidden
    ///
    public enum UploadPhotoHidden: String, Codable, CaseIterable {
        case _1 = "1"
        case _2 = "2"
    }

    /// - POST /upload
    /// - Uploads a new photo to Flickr
    /// - parameter apiKey: (form)  
    /// - parameter photo: (form)  
    /// - parameter title: (form)  (optional)
    /// - parameter description: (form)  (optional)
    /// - parameter tags: (form)  (optional)
    /// - parameter isPublic: (form)  (optional)
    /// - parameter isFriend: (form)  (optional)
    /// - parameter isFamily: (form)  (optional)
    /// - parameter safetyLevel: (form)  (optional)
    /// - parameter contentType: (form)  (optional)
    /// - parameter hidden: (form)  (optional)
    /// - returns: AnyPublisher<[String: Any], Error> 
    open func uploadPhoto(apiKey: String, photo: Data, title: String? = nil, description: String? = nil, tags: String? = nil, isPublic: UploadPhotoIsPublic? = nil, isFriend: UploadPhotoIsFriend? = nil, isFamily: UploadPhotoIsFamily? = nil, safetyLevel: UploadPhotoSafetyLevel? = nil, contentType: UploadPhotoContentType? = nil, hidden: UploadPhotoHidden? = nil) -> AnyPublisher<[String: Any], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/upload"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                let multipartBoundary = String(format: "Boundary+%08X%08X", arc4random(), arc4random())
                var multipartData = Data()
				let apiKeyHeader = "--\(multipartBoundary)\r\n"
				    .appending("Content-Disposition:form-data; name=\"apiKey\"\r\n")
				    .appending("\r\n")
				multipartData.append(apiKeyHeader.data(using: .utf8) ?? Data())
				multipartData.append(apiKey.data(using: .utf8) ?? Data())
				multipartData.append("\r\n".data(using: .utf8) ?? Data())

				let photoHeader = "--\(multipartBoundary)\r\n"
				    .appending("Content-Disposition:form-data; name=\"photo\"; filename=\"photo\"\r\n")
				    .appending("\r\n")
				multipartData.append(photoHeader.data(using: .utf8) ?? Data())
				multipartData.append(photo)
				multipartData.append("\r\n".data(using: .utf8) ?? Data())

				if let title = title {
					let titleHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"title\"\r\n")
					    .appending("\r\n")
					multipartData.append(titleHeader.data(using: .utf8) ?? Data())
					multipartData.append(title.data(using: .utf8) ?? Data())
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let description = description {
					let descriptionHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"description\"\r\n")
					    .appending("\r\n")
					multipartData.append(descriptionHeader.data(using: .utf8) ?? Data())
					multipartData.append(description.data(using: .utf8) ?? Data())
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let tags = tags {
					let tagsHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"tags\"\r\n")
					    .appending("\r\n")
					multipartData.append(tagsHeader.data(using: .utf8) ?? Data())
					multipartData.append(tags.data(using: .utf8) ?? Data())
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let isPublic = isPublic {
					let isPublicHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"isPublic\"\r\n")
					    .appending("\r\n")
					multipartData.append(isPublicHeader.data(using: .utf8) ?? Data())
					multipartData.append(isPublic.rawValue.data(using: .utf8) ?? Data())
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let isFriend = isFriend {
					let isFriendHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"isFriend\"\r\n")
					    .appending("\r\n")
					multipartData.append(isFriendHeader.data(using: .utf8) ?? Data())
					multipartData.append(isFriend.rawValue.data(using: .utf8) ?? Data())
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let isFamily = isFamily {
					let isFamilyHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"isFamily\"\r\n")
					    .appending("\r\n")
					multipartData.append(isFamilyHeader.data(using: .utf8) ?? Data())
					multipartData.append(isFamily.rawValue.data(using: .utf8) ?? Data())
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let safetyLevel = safetyLevel {
					let safetyLevelHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"safetyLevel\"\r\n")
					    .appending("\r\n")
					multipartData.append(safetyLevelHeader.data(using: .utf8) ?? Data())
					multipartData.append(safetyLevel.rawValue.data(using: .utf8) ?? Data())
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let contentType = contentType {
					let contentTypeHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"contentType\"\r\n")
					    .appending("\r\n")
					multipartData.append(contentTypeHeader.data(using: .utf8) ?? Data())
					multipartData.append(contentType.rawValue.data(using: .utf8) ?? Data())
					multipartData.append("\r\n".data(using: .utf8) ?? Data())
				}

				if let hidden = hidden {
					let hiddenHeader = "--\(multipartBoundary)\r\n"
					    .appending("Content-Disposition:form-data; name=\"hidden\"\r\n")
					    .appending("\r\n")
					multipartData.append(hiddenHeader.data(using: .utf8) ?? Data())
					multipartData.append(hidden.rawValue.data(using: .utf8) ?? Data())
				}

                multipartData.append("\r\n--\(multipartBoundary)--\r\n".data(using: .utf8) ?? Data())
                request.httpBody = multipartData
                request.setValue("\(multipartData.count)", forHTTPHeaderField: "Content-Length")
                request.setValue("multipart/form-data; boundary=\(multipartBoundary)", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[String: Any], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    if let object = try JSONSerialization.jsonObject(with: response.data, options: []) as? [String: Any] {
                        return object
                    } else {
                        throw OpenAPITransportError.invalidResponseMappingError(data: response.data)
                    }
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
