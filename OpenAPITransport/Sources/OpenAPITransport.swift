// OpenAPITransport.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine

// MARK: - Policy

/// Policy to define whether response is successful or requires authentication
public protocol URLResponsePolicy {
    func defineState(for request: URLRequest, output: URLSession.DataTaskPublisher.Output) -> AnyPublisher<URLResponseState, Never>
}

public enum URLResponseState {
    // Return success to client
    case success
    // Return error to client
    case failure
    // Repeat request
    case retry
}

final class DefaultURLResponsePolicy: URLResponsePolicy {
    func defineState(for request: URLRequest, output: URLSession.DataTaskPublisher.Output) -> AnyPublisher<URLResponseState, Never> {
        let state: URLResponseState
        switch (output.response as? HTTPURLResponse)?.statusCode {
        case .some(200...299): state = .success
        default: state = .failure
        }
        return Just(state).eraseToAnyPublisher()
    }
}

/// Define how to customize URL request before network call
public protocol URLRequestProcessor {
    /// Customize request before performing. Add headers or encrypt body for example.
    func enrich(request: URLRequest) -> AnyPublisher<URLRequest, OpenAPITransportError>
    /// Customize response before handling. Decrypt body for example.
    func decode(output: URLSession.DataTaskPublisher.Output) -> AnyPublisher<URLSession.DataTaskPublisher.Output, OpenAPITransportError>
}

final class DefaultURLRequestProcessor: URLRequestProcessor {
    func enrich(request: URLRequest) -> AnyPublisher<URLRequest, OpenAPITransportError> {
        Just(request)
            .setFailureType(to: OpenAPITransportError.self)
            .eraseToAnyPublisher()
    }

    func decode(output: URLSession.DataTaskPublisher.Output) -> AnyPublisher<URLSession.DataTaskPublisher.Output, OpenAPITransportError> {
        Just(output)
            .setFailureType(to: OpenAPITransportError.self)
            .eraseToAnyPublisher()
    }
}

// MARK: - OpenAPITransport

public protocol OpenAPITransport: AnyObject {
    var baseURL: URL? { get }

    func send(request: URLRequest) -> AnyPublisher<OpenAPITransportResponse, OpenAPITransportError>

    func cancelAll()
}

public struct OpenAPITransportResponse {
    public let data: Data
    public let statusCode: Int

    public init(data: Data, statusCode: Int) {
        self.data = data
        self.statusCode = statusCode
    }
}

public struct OpenAPITransportError: Error, CustomStringConvertible, LocalizedError {
    public let statusCode: Int
    public let description: String
    public let errorDescription: String?
    // It might be source network error
    public let nestedError: Error?
    // Data may contain additional reason info (like json payload)
    public let data: Data

    public init(
        statusCode: Int,
        description: String? = nil,
        errorDescription: String? = nil,
        nestedError: Error? = nil,
        data: Data = Data()
    ) {
        self.statusCode = statusCode
        self.errorDescription = errorDescription
        self.nestedError = nestedError
        self.data = data
        if let description = description {
            self.description = description
        } else {
            var summary = "OpenAPITransportError with status \(statusCode)"
            if let nestedError = nestedError {
                summary.append(contentsOf: ", \(nestedError.localizedDescription)")
            }
            self.description = summary
        }
    }
}

// Custom transport errors. It begins with 6.. not to conflict with HTTP codes (it begins with 5..)
public extension OpenAPITransportError {
    static let incorrectAuthenticationCode = 600
    static func incorrectAuthenticationError(_ nestedError: Error? = nil) -> OpenAPITransportError {
        OpenAPITransportError(
            statusCode: OpenAPITransportError.incorrectAuthenticationCode,
            description: "Impossible to add authentication headers to request",
            errorDescription: NSLocalizedString(
                "Impossible to add authentication headers to request",
                comment: "Incorrect authentication"
            ),
            nestedError: nestedError
        )
    }

    static let failedAuthenticationRefreshCode = 601
    static func failedAuthenticationRefreshError(_ nestedError: Error? = nil) -> OpenAPITransportError {
        OpenAPITransportError(
            statusCode: OpenAPITransportError.failedAuthenticationRefreshCode,
            description: "Error while refreshing authentication",
            errorDescription: NSLocalizedString(
                "Error while refreshing authentication",
                comment: "Failed authentication refresh"
            ),
            nestedError: nestedError
        )
    }

    static let noResponseCode = 603
    static func noResponseError(_ nestedError: Error? = nil) -> OpenAPITransportError {
        OpenAPITransportError(
            statusCode: OpenAPITransportError.noResponseCode,
            description: "There is no HTTP URL response",
            errorDescription: NSLocalizedString(
                "There is no HTTP URL response",
                comment: "No response"
            ),
            nestedError: nestedError
        )
    }

    static let badURLCode = 604
    static func badURLError(_ nestedError: Error? = nil) -> OpenAPITransportError {
        OpenAPITransportError(
            statusCode: OpenAPITransportError.badURLCode,
            description: "Request URL cannot be created with given parameters",
            errorDescription: NSLocalizedString(
                "Request URL cannot be created with given parameters",
                comment: "Bad URL"
            ),
            nestedError: nestedError
        )
    }

    static let invalidResponseMappingCode = 605
    static func invalidResponseMappingError(data: Data) -> OpenAPITransportError {
        OpenAPITransportError(
            statusCode: OpenAPITransportError.invalidResponseMappingCode,
            description: "Response data cannot be expected object scheme",
            errorDescription: NSLocalizedString(
                "Response data cannot be expected object scheme",
                comment: "Invalid response mapping"
            ),
            data: data
        )
    }

    static let retryErrorCode = 606
    static let retryError = OpenAPITransportError(statusCode: OpenAPITransportError.retryErrorCode)
}

public protocol URLSessionOpenAPITransportDelegate: AnyObject {
    func willStart(request: URLRequest)
    func didFinish(request: URLRequest, response: HTTPURLResponse?, data: Data)
    func didFinish(request: URLRequest, error: Error)
}

open class URLSessionOpenAPITransport: OpenAPITransport {
    private var cancellable = Set<AnyCancellable>()
    public var config: Config
    public var baseURL: URL? { config.baseURL }

    public init(config: Config = .init()) {
        self.config = config
    }

    open func send(request: URLRequest) -> AnyPublisher<OpenAPITransportResponse, OpenAPITransportError> {
        
        config.processor
            // Add custom headers or refresh token if needed
            .enrich(request: request)
            .flatMap { request -> AnyPublisher<OpenAPITransportResponse, OpenAPITransportError> in
                self.config.delegate?.willStart(request: request)
                // Perform network call
                return self.config.session.dataTaskPublisher(for: request)
                    .mapError {
                        self.config.delegate?.didFinish(request: request, error: $0)
                        return OpenAPITransportError(statusCode: $0.code.rawValue, description: "Network call finished fails")
                    }
                    .flatMap { output in
                        self.config.processor.decode(output: output)
                    }
                    .flatMap { output -> AnyPublisher<OpenAPITransportResponse, OpenAPITransportError> in
                        let response = output.response as? HTTPURLResponse
                        self.config.delegate?.didFinish(request: request, response: response, data: output.data)
                        return self.config.policy.defineState(for: request, output: output)
                            .setFailureType(to: OpenAPITransportError.self)
                            .flatMap { state -> AnyPublisher<OpenAPITransportResponse, OpenAPITransportError> in
                                switch state {
                                case .success:
                                    let transportResponse = OpenAPITransportResponse(data: output.data, statusCode: 200)
                                    return Result.success(transportResponse).publisher.eraseToAnyPublisher()
                                case .retry:
                                    return Fail(error: OpenAPITransportError.retryError).eraseToAnyPublisher()
                                case .failure:
                                    let code = response?.statusCode ?? OpenAPITransportError.noResponseCode
                                    let transportError = OpenAPITransportError(statusCode: code, data: output.data)
                                    return Fail(error: transportError).eraseToAnyPublisher()
                                }
                            }.eraseToAnyPublisher()
                    }
                    .eraseToAnyPublisher()
            }
            .retry(times: 2) { error -> Bool in
                return error.statusCode == OpenAPITransportError.retryError.statusCode
            }.eraseToAnyPublisher()
    }

    open func cancelAll() {
        cancellable.removeAll()
    }
}

public extension URLSessionOpenAPITransport {
    struct Config {
        public var baseURL: URL? = nil
        public var session: URLSession = .shared
        public var processor: URLRequestProcessor = DefaultURLRequestProcessor()
        public var policy: URLResponsePolicy = DefaultURLResponsePolicy()
        public weak var delegate: URLSessionOpenAPITransportDelegate?

        public init() {}

        public init(baseURL: URL) {
            self.baseURL = baseURL
        }
    }
}

fileprivate extension Publishers {
    struct RetryIf<P: Publisher>: Publisher {
        typealias Output = P.Output
        typealias Failure = P.Failure

        let publisher: P
        let times: Int
        let condition: (P.Failure) -> Bool

        func receive<S>(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
            guard times > 0 else { return publisher.receive(subscriber: subscriber) }

            publisher.catch { (error: P.Failure) -> AnyPublisher<Output, Failure> in
                if condition(error)  {
                    return RetryIf(publisher: publisher, times: times - 1, condition: condition).eraseToAnyPublisher()
                } else {
                    return Fail(error: error).eraseToAnyPublisher()
                }
            }.receive(subscriber: subscriber)
        }
    }
}

fileprivate extension Publisher {
    func retry(times: Int, if condition: @escaping (Failure) -> Bool) -> Publishers.RetryIf<Self> {
        Publishers.RetryIf(publisher: self, times: times, condition: condition)
    }
}
